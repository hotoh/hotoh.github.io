5	Gadget 规范
5.1	明确Gadget含义
UEE gadget 是独立的、具有业务语义的自定义组件。可以理解为一个页面中的一个区块。
Gadget抽取可以理解为业务对前端代码的组件化的过程，在一个大型Web项目中，通过组件化来组织代码，无疑对后续项目的维护、管理带来便利。
抽取Gadget的三个目的：可复用性、可维护性、可定制性。为了页面代码方便维护（比如可以使代码简洁、预编译、静态化等）、方便定制（比如可以页面编排、控制定制范围等），我们就会开发Gadget，所以可维护性、可定制性是所有Gadget的两个默认属性。
5.2	Gadget六个基本特征
	唯一标识
具备整个系统全局唯一的编号，提供功能描述和示例图片
	完全自治
即自给自足，除了系统公共代码外，自己提供html/css/js/images/font
	无状态
	不依赖上下文，不依赖父组件、兄弟组件、子组件的常量、变量、属性、事件等
	MVC分层原则
模型(model)-视图(view)-控制器(controller)分层解耦，业务逻辑、数据和呈现分离
	高内聚松耦合
独立功能的模块，可动态插拔和替换，高内聚松耦合
	遵守安全边界
只通过属性、事件和外部通信，按规范实现互通信。
gadget中的数据来源只能通过下面两种方式，
一是gadget内部通过服务直接从服务端获取，
二是通过gadget的属性传递进来。

详见 http://rnd-soa.huawei.com/uee/doc/guide/#/item/gadget
5.3	Gadget定义规范
5.3.1	在“*.gadget”文件中定义一系列元数据。
一般来说，会定义3个组件的属性，例如

1.	<!-- 
2.	@description 
3.	这里是gadget的描述信息，可以在这里描述此gadget的用途；
4.	-->
5.	
6.	<!-- gadget唯一id命名，该name会自动转换为my-photoalbum作为class属性，如-->
7.	<uee:gadget-define name="bes:ad-custinfo" class="bes-ad-custinfo">
     <!-- 输出模型-->
    <uee:gadget-attr property="model"></uee:gadget-attr>
    <!-- 校验模型数组 -->
    <uee:gadget-attr property="validate"></uee:gadget-attr>
    <!-- 添加外部依赖 -->
    <uee:gadget-attr property="params"></uee:gadget-attr>
8.	     <!-- gadget引用静态资源建议使用{{$Gadget.$Path}}引用本gadget路径下的资源-->
    <link type = "text/css" rel="stylesheet" ng-href="$Gadget.$Path  + ‘/ bes-ad-custinfo.css’"/>
    <uee:script src="{{$Gadget.$Path + '/bes-ad-custinfo.js'}}"></uee:script>
    <uee:include src="$Gadget.$Path + '/bes-ad-custinfo.html'"></uee:include>
9.	</uee:gadget-define>

说明：
	model 表示gagdet内部需要发布给外部使用的模型
	params 表示gadget使用时，可能引用到外部的数据
	validate 表示校验函数，当存在多个组件，同时外部提交按钮会触发关联的gadget内的校验时使用
注意：
1、<uee:gadget-attr>，只有用property是使用对象的引用类型，否则都是String类型。2、property和name是无法区分大小写的，推荐全部使用小写。
5.4	Gadget使用规范
5.4.1	在页面引入gadget
推荐通过如下方式引入gadget：
1.	<bes:iot-custinfo gadget name=”cust1”></bes:iot-custinfo >
5.4.2	Gadget交互
通常存在如下几种场景：父子关系的Gadget，兄弟关系的Gadget，Gadget内本身与弹出框交互。
	设置Gadget入参和出参，相互调用。
	通过发布和订阅自定义事件实现gadget间交互。

2.	<uee:fire event="$autoEvent" script="$Ctrl.catchAutoEvent(jevent.$DATA)"></uee:fire>

3.	$Gadget.$Emit("$autoEvent", $Gadget.data)
注意：尽量不使用自定义事件，因为事件本身意味着触发源不可控，具体行为不明确，维护困难。
	父子关系和兄弟关系的Gadget推荐使用属性定义参数，进行传参，不推荐事件触发
	弹出框来，通过制定作用域（$Fire中的第二个参数），可以让弹出框直接访问到原Gadget内的变量，这样就不必每个弹出框，搞单独的Gadget。
5.4.3	Gadget内部文件引用
Gadget组件要高内聚，低耦合，因此Gadget文件内部仅允许引用gadget使用的uslx、js,禁止引用其他js、uslx等文件。
背景：
	多次引用公共js文件，如果存在重写UEE框架或者其他方法，会导致陷入死循环。
	Js文件支持同名同路径定制覆盖基线，如果gadget中引入的非内部的js代码覆盖了父页面中相同的逻辑， 则逻辑会出现在引入gadget后导致的差异。
5.5	Gadget最佳实践举例
5.5.1	gadget必须有全系统唯一的name
      gadget是以唯一name进行区分调用，对于大型Web项目来说，运行态涉及到多个模块集成，对gadget的命名建议使用系统名-模块名-gadget名的方式进行命名。 
5.5.2	gadget保持独立性
      当gadget确实需要跟外界进行交互时，一是通过gadget属性传递对象，二是通过uee:fire去订阅和发布事件。
5.5.3	避免在gadget内部使用页面级别的变量、Dom元素
5.5.4	gadget的资源内聚
      一个gadget相关的html/js/css/images资源建议在物理形态上放在一个目录，便于后续gadget维护，分享，重用。
.gadget文件引用的内部资源，使用$Path，进行关联引用，避免js文件到处被使用，造成方法定义的混乱。
内部引用的样式文件，如果非基础类样式（base.css），请务必用gadget对应的class作为选择器的命名空间，否则样式冲突很难处理。
 
5.5.5	gadget内部js资源中的函数定义建议使用$Controller定义，使用跟gadget名关联的全局唯一命名空间
gadget内部的js资源，在申明函数时，建议使用$Controller申明带命名空间的函数名，如：

$Controller("simCardStatus",function(){})
gadget内部css资源中的选择器建议使用跟gadget名关联的全局唯一命名空间
5.5.1	gadget内部的js代码加载时不直接操作Dom
      在gadget中定义的js文件，在加载时，避免执行操作dom，而应该只是定义函数，具体操作dom的时机由uee:fire组件触发。 避免由于后续预编译时gadget内部js文件被提取合并引起的代码执行顺序问题，导致的js错误。
例如：
错误代码：
<script>
var printCelljsyd = $('.cellweb');
printCelljsyd.Login("华为技术有限公司","","13100104539","6140-1517-0123-3005");
</script>
正确代码：

<uee:fire init script=” $Controller.bes.xxxxPage.init()”></uee:fire>
<script>
$Controller("bes.xxxxPage",{
init:function(){
var printCelljsyd = $('.cellweb');
printCelljsyd.Login("华为技术有限公司","","13100104539","6140-1517-0123-3005");
}
})
</script>


6	性能最佳实践
6.1	遍历列表元素，推荐使用标准的for循环或者$.each，不要使用for-in循环，$.each存在嵌套循环时候变量不要使用同一个 。
 for-in循环在遍历对象的时候总是会去遍历该对象的原型链所有的属性，并且唯一阻止的方法是使用hasOwnProperty来判断，这给遍历增加了额外的压力。循环数组还是推荐for循环，并且在for循环开始时缓存数组长度。
6.2	避免过多的使用全局变量，全局变量使用完毕，及时清空
      局部变量的访问速度要比全局变量的访问速度更快，因为全局变量其实是window对象的成员，而局部变量是放在函数的栈里的。 另外，过多的使用全局变量会导致变量命名混乱，容易导致冲突，在代码复用的过程中可能会出现问题,使用之后及时清空。
6.3	减少对象查找
      因为js是解释性语言，如a.b.c.d这样的对象，js会先去检查a再检查a中的b， 再检测b中的c…一直查找下去，所以页面如果写很多这样的对象查找会有性能问题，建议减少这样的对象查找。如下面的例子：
不推荐：

if ("rsclT.fixnum.ZYTT" == $Page.selectedNumberList[i].itemTypeId)
{
    $Gadget.orderItemInfo[0].orderItemResource[i] = {};
    $Gadget.orderItemInfo[0].orderItemResource[i].actionType = "A";
    $Gadget.orderItemInfo[0].orderItemResource[i].resourceType = $Page.selectedNumberList[i].itemTypeId;
    $Gadget.orderItemInfo[0].orderItemResource[i].identityId = $Page.selectedNumberList[i].telNum;
    $Gadget.orderItemInfo[0].orderItemResource[i].lockCode = $Page.selectedNumberList[i].itemTypeId + "," + $Page.selectedNumberList[i].telNum;
    $Gadget.orderItemInfo[0].orderItemResource[i].lockType = "1";
}

推荐：

1.	var tempObj = $Page.selectedNumberList[i]
2.	if ("rsclT.fixnum.ZYTT" == tempObj.itemTypeId){
3.	    $Gadget.orderItemInfo[0].orderItemResource[i] = {
4.	        actionType : "A",
5.	        resourceType : tempObj.itemTypeId,
6.	        identityId : tempObj.telNum,
7.	        lockCode : tempObj.itemTypeId + "," + tempObj.telNum,
8.	        lockType : "1"
9.	    };
10.	}


6.4	使用ngIf阻止没有必要的渲染
       页面中控制DOM的显示隐藏，可以使用ngIf，也可以使用ngShow，但是两者有本质的区别。如果没必要一次加载完所有的DOM，推荐使用ngIf。原因如下：ngShow类似CSS的display，在表达式为false的时候，会隐藏DOM节点。当DOM load的时候，ngShow里面的所有节点都会被加载。也就意味着，如果有太多的ngShow指令，及时他们不显示，其所在的DOM节点还是会被渲染的。
       ngIf的表达式为false的时候，它控制的节点没有被创建或者之前的节点已经被销毁掉。因此ngIf所控制的节点中有很多其他指令或者绑定，它们都不会被执行。因此ngIf可以阻止没有必要的渲染。

6.5	优化ngRepeat
      ngRepeat会进行大量的DOM操作，列表过长会导致单个页面内过多的DOM操作，对页面性能造成严重的影响。当angularjs处理2500个以上的数据双向绑定时，速度就会很慢。缓解该问题的最好方法是通过分页、无限滚动条加载等手段限制所显示列表的大小。
      另外，ngRepeat可以使用track by表达式减少不必要的DOM操作。ngRepeat会依据一个key来跟踪每一个对象是否发生变化，来判断数据有更新，进而来判断，是否进行DOM更新操作。如果没有提供track by表达式，会使用默认的 $$hashkey，这意味着只要当引用发生变化，而不管数据有没有变化，ngRepeat都会重新$compile DOM——这显然不是我们想要的。所以，提供一个track by表达式，如：

ng-repeat="item in items track by $index"
则会使 ngRepeat依据每一个对象在数据库里面的id字段来判断数据是否更新，减少了不必要的DOM操作。
注意，在使用track by表达式的时候，一定要保证列表中每一项根据表达式求值的结果要唯一，否则会报错。
6.6	不要在popin时进行异步操作
       popin关闭弹出页的fire中不要进行异步操作。Popin应该做的事情就是关闭弹出页，仅此而已。当弹出页被关闭时，其DOM已经被销毁，相应的弹出页的scope也会被回收，不然会有严重内存泄露问题。如果此时进行异步操作，且这些异步执行的代码中又使用到弹出页的相关内容，比如scope域，则会产生开发者预料之外的结果。既然scope在DOM销毁时必须回收，UEE保证不了业务这种异步写法执行的正确性。
      如果期望关闭弹出页的时候，执行一些业务逻辑，我们推荐的写法是类似这样的：
1.	<button type="button">关闭
2.	   <uee:fire service="..." onafter="abc(this.$Get('$Fire'))"></uee:fire>
3.	</button>
在函数abc中最后使用$Fire({popin:""})进行关闭弹出页。
      总之，如果期望关闭弹出页的“同时”执行自己的业务逻辑，需要在最后执行的js代码中使用$Fire来关闭。

6.7	Fire的region范围应尽量小
       region配置为$Root、$Model开头的基于前台模型的表达式，例如$Root.a.b.c、$Model.e.f等，用来将前台相应的值提交到后台，供后台服务使用。 Region范围写得过大，则传输冗余数据过多，影响请求前后台交互的效率。
      比如仅仅需要传$Model.regionList这个对象，fire可以写作：
1.	<uee:fire region="$Model.regionList" service="demo/checklist"></uee:fire>
      像下面的写法，整个$Model都会被传送到后台：
1.	<uee:fire region="$Model" service="demo/checklist"></uee:fire>
因此，fire的region范围应该尽量小。

6.8	正确使用fire的init属性
       <uee:fire>提供init属性，它接受一个表达式，当此表达式值为true时，该fire将被执行。如果init属性为空，则该fire在页面加载到它的时候执行。假如有在某个条件下执行一段业务逻辑的场景时，可以考虑使用fire的init属性。
       比如要在一个HTML元素$(“#abc”)加载时执行JS函数functionName()，则可以写作下面的方式：
禁止使用control调用方法control=””
1.	 <div ng-if="$Page.xxx">
2.	   <div id="abc">
3.	        <uee:fire init script="functionName()"></uee:fire>
4.	   </div>
5.	</div>
这里，div加载后，fire init会自动执行。
6.9	不要在循环中重复绑定fire
      在开发页面时，有很多根据业务模型迭代出DOM的场景，而这些DOM都需要绑定相同或类似的<uee:fire>进行一些业务逻辑处理。
      例如，给循环中迭代出的每个下拉框绑定fire监听其change事件，当前业务一些开发人员会这么写：
1.	<div ng-repeat="$ChildItem in $Item.attributes" ng-if="$ChildItem.showType != 'HIDDEN'" class="form_group per45">
2.	    <div ng-if="$ChildItem.showType == 'SINGLE_SEL'" oc-select
3.	        x-property="$ChildItem.newValue" x-items="$ChildItem.options"
4.	        class="form_control form_droplist">
5.	        <div class="Droplist">
6.	            <div class="DroplistHeader">
7.	                <input type="text" class="inputbox" unselectable="on" readonly="readonly" />
8.	            </div>
9.	        </div>
10.	        <uee:fire event="change" script="$Controller.bes.group.commattr.special.dealSingleSelChangeAction($Gadget,$ChildItem,findex)"></uee:fire>
11.	        
12.	    </div>
13.	</div>
      这样写性能有问题，因为每次迭代出一个div，就要绑定一个fire。当被迭代数组长度较大的时候，页面性能可能会比较差了。这种情况可以用fire的bind和selector属性来做，性能更高。比如上面的例子可以写作：
1.	<div ng-repeat="$ChildItem in $Item.attributes" ng-if="$ChildItem.showType != 'HIDDEN'" class="form_group per45">
2.	    <div ng-if="$ChildItem.showType == 'SINGLE_SEL'" oc-select
3.	        x-property="$ChildItem.newValue" x-items="$ChildItem.options"
4.	        class="form_control form_droplist oc_select">
5.	        <div class="Droplist">
6.	            <div class="DroplistHeader">
7.	                <input type="text" class="inputbox" unselectable="on" readonly="readonly" />
8.	            </div>
9.	        </div>
10.	    </div>
11.	</div>
12.	<uee:fire bind="idv" selector=".oc_select" event="change" script="$Controller.bes.group.commattr.special.dealSingleSelChangeAction($Gadget,jEvent.$Scope().$ChildItem,jEvent.$Scope().findex)"></uee:fire>
13.	
      这样可以只用写一个fire，绑定一次即可，类似jQuery的事件代理机制。需要注意的是，原来fire直接下载ngRepeat下， fire的script函数中可以直接传入this作为当前scope或当前scope上的变量；改为fire只绑一次，这种方式就不行了，不过可以通过jEvent.$Scope()方式取到对应scope。

6.10	 RSP节点前台避免直接查询数据库、修改数据，如有相关需求要调用后台接口实现。
也就是说在omni路径下的bs.xml文件中禁止出现对DB类型的ENTITY进行增加、删除、修改的操作，可以查询。
原因：如果前台修改了数据，同时又调用了后台的服务，那么前台和后台是两个事物，无法做到事物一致性，可能导致死锁。
J
7	前端安全规范
7.1	 Rest请求中的参数禁止出现上下文中的数据（操作员信息+3户信息等），如果必须传递，则后台必须进行校验 (数据权限校验)   
7.2	参数灵活的BS，API禁止Rest调用， 由前端封装omni层BS组装参数进行调用
7.3	敏感数据需要进行加密传输
7.4	账号、密码等数据禁止浏览器保存，防止他人使用造成信息泄露
7.5	前台有的功能权限、业务数据、受理范围等校验能力后台需要同时具备
7.6	业务逻辑处理优先放在后台，前台不要多次调用后台功能来实现，会导致性能降低、安全问题等
8	常识性规范
8.1	蓝色按钮一般是引导用户必须操作 灰色是可选操作 
8.2	与数据库存在交互的按钮要有防重复提交功能
8.3	有结算页面的业务点击上一步，需要能够继续提交，修改之后能够拼装正确报文
8.4	新增的bp业务，批量字典和单个字典都需要加上，在查询订单页面和操作日志查询菜单上正确展示业务编码
8.5	页面修改了某一条数据后，要刷新页面展示内容。
8.6	变更业务，内容未变更的不允许提交，要有相应提示信息
8.7	可以直接在html下的uslx中写代码片段即可，不用为了使用Gadget而使用，增加维护难度。
8.8	数据量较大的展示默认采取分页查询
8.9	已上线的菜单权限，禁止修改权限ID，如果必须修改，需要割接已上线的角色权限相关的实例化数据，不能影响客户使用。
参考资料
UEE 开发指南 http://rnd-soa.huawei.com/uee/doc/guide/#
问题提问，下面的代码都有哪些问题？：
以下所有代码片段均取自咱们环境上的真实代码
66.1 <!doctype html>
页面解析报错：The markup in the document preceding the root element must be well-formed.
解决方案：<!doctype html>修改为<!DOCTYPE html>
在使用SAXReader解析html页面时报错，后续新建页面注意一下标准写法
66.2 打开看（注释不规范）
 
66.3 <bes:figure class="hlds-image--info hlds-show--inline-block" src="" size="small" variant="1-by-1"></bes:figure>
空链接属性是指img、link、script、ifrrame元素的src或href属性被设置了，但是值却为空。如<img src=””>，这种标签浏览器依旧会以默认的规则去请求空地址。
66.4 这段代码格式上有什么问题吗？（运算符要在另起一行的开头）
if (initialPayInfo.bankId != $Gadget.data.payInfo.bankId || initialPayInfo.bankAcctName != $Gadget.data.payInfo.bankAcctName ||
                initialPayInfo.bankAcctCode != $Gadget.data.payInfo.bankAcctCode || initialPayInfo.paymentPlanList[0].contractNum != $Gadget.data.payInfo.paymentPlanList[0].contractNum ||
                initialPayInfo.paymentPlanList[0].effeDate != $Gadget.data.payInfo.paymentPlanList[0].effeDate) {
                $Gadget.isChangedPayInfoFlag = true;
            }
66.5 jQuery.validator.addMethod("BankAccount", function (value, element, param) {})
BankAccount应该为bankAccount（变量小驼峰）
