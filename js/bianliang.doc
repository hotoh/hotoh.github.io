内置前端变量
一、概述
UEE主要提供了$Webapp、$Model、$Page等内置前端变量。

业务模型变量	辅助模型变量	生命周期	说明
---	$Webapp	session	对应Web Root根。说明：除了app.js和app.css本身，不再使用resource.root这种前辍来引用 部署名称。
---	$Global	window	windows级别的前端辅助变量，用于多business前端共享信息。
---	$Page	step view .uslx	$Page：step级的纯前端辅助变量。$Page初始化：步骤跳转时更新变量，由<uee:view>指令负责初始化；框架确保根scope初始化一份，以便在无<uee:view>时可用。
$Model	---	business页面级	$Model：REST服务在前端模型的映射；在business中多个step页面间共享数据。
$Params	---	.html .uslx(*.tagx)片段	1、页面加载时就可用。2、include时创建子更新。类似JSP attribute。
$Gadget.tdata	$Gadget	<gadget>	$Gadget用于在gadget内部操作对象的根。$Gadget.tdata用来获取业务模型的相关数据。
二、用法参考
2.1 $Webapp
Web Root的根，主要做资源路径引用时使用，示例参考：

<div>
  // 使用$Webapp引用片段页面
  <uee:include src="'{{$Webapp}}/example/include/another.business.html'"></uee:include>
</div>
考虑到浏览器加载机制，对于css及img的加载不推荐使用$Webapp ，推荐使用resource.root替代之，不推荐原因

2.2 $Global
该变量隶属window下的全局变量，可满足页面间数据共享(小量)，不建议将其作为数据传递的手段，示例参考：

1、Angular标签

// 全局设置语言
<span ng-init='$Global.$Lang("zh_CN")'></span>
2、Fire

<script>
  function operater($Global) {
    // 全局设置语言
    $Global.$Lang("zh_CN");
    // 全局设置变量
    $Global.xxx = yyy;
    ...
  }
</script>
<uee:fire init script="operater($Global)"></uee:fire>
2.3 $Model
该变量生命周期依附于引用它的页面，可辅助业务处理前端业务逻辑，常见场景示例参考(非Gadget代码)：

1、作为rest服务前端模型映射，自动更新页面视图

<uee:fire service="xxx/yyy" target="$Model.data"></uee:fire>
或者JS中使用$Fire
<script>
$Fire(
    {
      service : "xxx/yyy",
      target : "$Model.data"
      ...
    }
);
</script>
// 以下视图会随模型改变自动刷新
<table class="uee-xtable">
 <tr>
  <th>xxx</th>
  ...
 </tr>
 <tr ng-repeat="$Rowdata in $Model.data">
  <td>
    <span ng-bind="$Rowdata.xxx"></span>
  </td>
 ...
 </tr>
</table>
2、business-step之间共享数据

在business-step使用中，$Model变量在多个step页面片段中共享,即step间跳转时它可以作为数据传递的媒介

<business start-step="step1">
    <step name="step1" view="demoA.uslx"></step>
    <step name="step2" view="demoB.uslx"></step>
</business>
<uee:page></uee:page>
demoA.uslx片段：
<uee:view>
    ...
    <input class="uee-input-normal" property="$Model.name" />
    ...
</uee:view>
demoB.uslx片段：
<uee:view>
    ...
    // 可获取到由step1页面中的数据
    {{$Model.name}}
    ...
</uee:view>
2.4 $Page
该变量为纯前端辅助变量，即业务可在前端页面中使用它处理业务逻辑，常见场景示例参考:

1、页面

<script>
  function init($Page) {
    // 通过$Page设置input的值
    $Page.number = "d00293539";
    ...
  }
</script>
<uee:fire init script="init($Page)"></uee:fire>
<input class="uee-input-normal" property="$Page.number" />
...
2、business-step

$Page变量与business-step使用时，在不同的step间跳转，$Page都会重新初始化，即step间数据不共享

<business start-step="step1">
    <step name="step1" view="demoA.uslx"></step>
    <step name="step2" view="demoB.uslx"></step>
</business>
<uee:page></uee:page>
demoA.uslx片段：
<uee:view>
    ...
    <input class="uee-input-normal" property="$Page.name" />
    <button class="uee-button"> 下一步
      <uee:fire targetstep="step2"></uee:fire>
    </button>
    ...
</uee:view>
demoB.uslx片段：
<uee:view>
    ...
    // 无法获取step1页面中的数据
    {{$Page.name}}
    <button class="uee-button"> 上一步
      <uee:fire targetstep="step1"></uee:fire>
    </button>
    ...
</uee:view>
注：当点击上一步按钮时，step1中页面的输入值将被清空。

2.5 $Gadget
gadget文件中使用的域变量，其生命周期根植与gadget文件中；gadget内部不推荐使用$Model及$Page等前端变量。

gadget
目录
1 什么是gadget
2 为什么需要gadget
3 gadget的特性
3.1 gadget的独立性
3.2 gadget支持嵌套吗
3.3 gadget与include的区别
3.4 gadget与指令的区别
3.5 gadget与预编译
4 gadget的定义和使用
5 gadget的定制
5.1 页面级别的调整
5.1.1 Composer属性设置
5.1.2 gadget扩展点
5.2 系统级别的风格定制
5.2.1 多租下gadget的定制配置
6 gadget最佳实践
6.1 gadget必须有全系统唯一的name
6.2 gadget保持独立性
6.3 gadget的资源内聚
6.4 gadget内部js资源中的函数定义建议使用$Controller定义，使用跟gadget名关联的全局唯一命名空间
6.5 gadget内部css资源中的选择器建议使用跟gadget名关联的全局唯一命名空间
6.6 gadget定义需要显示指定gadget支持配置的属性
6.7 gadget内部的js代码加载时不直接操作Dom
1 什么是gadget
Google gadget：gadgets小工具是使用HTML，JavaScript，Flash或Silverlight开发的动态行为内置的迷你应用程序。可以在多个站点和平台上运行，有特殊的标签和自行加载的库。

UXE gadget ： 栏目（gadget）是指具体应用的模板，是相对于页面整体而言的，用来定义应用的样式、数据、模板文件等。栏目添加到页面后可实例化为应用，一个栏目可实例化为不同的应用。

UEE gadget：独立的、具有业务语义的自定义组件。

2 为什么需要gadget
      gadget抽取可以理解为业务对前端代码的组件化的过程，在一个大型Web项目中，通过组件化来组织代码，无疑对后续项目的维护、管理带来便利。

      举个例子，同样是编写代码，短代码通常比长代码更具可读性，大多开发语言里都会建议“一个函数最好不要超过多少多少行”是同样的道理。在web前端开发中，js是做的比较好的，现在很少有人会把所有js代码都写到一起，可以通过函数、文件进行拆分，业界还存在requirejs，seajs这些对js进行模块化的库；css也可以通过less、sass等方式进行模块化管理。而如何对页面中大量的html进行管理，大多是各式各样的组件化方案，如jQuery UI通过js函数式进行组件封装，angularjs提供指令的方式封装组件。

      UEE gadget的组件封装有何特别之处？gadget将html/js/css/img等组件构成的资源作为一个整体进行组件化，不仅解决了html本身的模块化，也解决了js/css的模块化加载使用，简单来说gadget中定义的html模板、引入的js、css资源只有在gadget在页面上被使用时才加载。

3 gadget特性
3.1 gadget的独立性
      我们定义gadget为一个独立的、具有业务语义的自定义组件。对于gadget来说，独立性应该如何理解？

      首先，gadget中的数据来源只能通过下面两种方式，一是gadget内部通过服务直接从服务端获取，二是通过gadget的属性传递进来。

      gadget内部的服务供给必须是独立的，也就是说gadget对应的服务应该是相对于gadget是原子级的，如果从服务逻辑上，确实需要后端多个服务组合完成，可以在后端采用服务编排的方式对服务进行组合，gadget中只看到原子服务。这样对在前端进行基于gadget的页面调整时，对于后端服务是透明的，现有的服务无需修改。 当一个页面片段本身的数据跟页面需要频繁交互时，从代码复用、代码模块化的角度，我们也可以将其包装成一个gadget，这时gadget可能不对应后端的一个独立的服务，其数据可以通过gadget的对象属性传递进来的，gadget内部消费属性对应的数据，对该数据做的修改自动与页面同步。

      除了直接通过属性共享对象的方式进行gadget与外部数据交互外，我们还可以通过事件与外部进行交互，当gadget有独立的服务供给数据，只是在gadget内做个别操作时，如提交数据等时需要对外界“通知”时，这时可以使用fire的事件机制在页面中交互，通过事件订阅、事件触发完成gadget之间的交互，事件本身跟gadget属性一样作为gadget的对外接口进行约束稳定。 gadget内部禁止直接使用页面级别的变量、dom等，如$Page，$Model这些变量，只能消费如$Gadget、$Attrs下的数据。

      其次，gadget所需的资源原则上内聚，gadget内部所需的js/css文件在gadget内部引用，gadget的资源加载机制会保证一个页面中，多个gadget实例中加载的资源只加载一次。 gadget的加载执行不依赖于页面中引入的公共js（app.js这种的公共js除外），多个gadget公用的js可以在一个公共位置存放，但需要在gadget中申明引用，而不是页面中引用。这样理论上同一个gadget，在任意的页面中都可以直接使用，这对后续通过web composer进行在线页面定制也是个前提。

3.2 gadget支持嵌套吗
      回答这个问题之前，我们想想什么场景下，gadget要支持嵌套。如号码选择gadget，从代码复用的角度来看，多个页面中均有这相同的业务逻辑，适合抽取成公用的gadget。 gadget在满足独立性的原则基础上，技术上嵌套是支持的。

3.3 gadget与include的区别
      不论是uee:include还是angularjs原生的ng-include指令，其本意都是代码片段的复用，从代码复用的观点来看，跟gadget本质上没有太大区别。

      两者的区别在于：

gadget不仅仅包含html片段，还有属于gadget的js/css/图片等资源，而include仅仅是html片段级别的复用。
gadget强调独立性，在gadget内部有独立的$Gadget对象可以使用，其跟页面级的其他对象是完全独立的，gadget内部禁止直接使用页面级的变量。
gadget更加语义化，强调“组件”的 概念，gadget包含的其他静态资源都属于gadget本身，include偏重于简单的代码片段重用，可以类比jsp:include与jsp tag的关系。
没有明显的业务语义化组件特性的纯代码复用，可以直接用include方式进行。

3.4 gadget与指令的区别
      angularjs本身提供了指令封装的概念，为何uee还需要构建gadget能力？

      1）屏蔽angularjs本身的学习成本，以DSL标签形式的gadget提供给业务使用，降低上手难度

      2）angularjs的指令定义本身不支持懒加载，业务自定义指令的话，那么在页面使用指令时，还需要手动通过<script>标签引入对应的js、css文件，失去了gadget资源自加载的能力。

      建议业务除非是在完成一个基础控件，如一个下拉框，封装时使用angular的指令能力封装。其他具有业务语义的组件抽取，建议以gadget形式进行。

3.5 gadget与预编译
      上面谈到通过gadget，可以使得业务的代码组件化，便于维护、复用，解决了开发维护效率的问题，但同时不可避免的，页面gadget化会因为多次ajax请求带来性能问题，特别是页面在一些古老的浏览器，如IE8上渲染时。

我们来看一个例子，如下图所示：

fig3_5_1

      原始开发模式中，一个html页面，引入了按功能分的若干个js/css文件，浏览器加载时首先下载html页面，在解析html时，遇到<script>节点开始下载js文件，遇到<link>节点开始下载css文件，当这些文件解析完了，页面的首屏也就显示出来了。

      假设我们通过gadget进行组件化拆分，使用7个gadget来组装页面，如下图所示：

fig3_5_2

那么浏览器在渲染页面的过程就变成下面这样了：

主页面html下载
              -----js资源下载解析
              ----css资源下载解析
                               ----gadget A请求
                                              ---- gadget A js请求
                                              ---- gadget A css请求
                               ----gadget B请求
                               ......
如上所示，gadget组件化后的页面带来了下面几个问题：

请求数变多
多了7个gadget本身的请求，以及gadget内部属于gadget的js/css请求，更进一步的每个gadget都会有独立的服务与其对应，可以预见到服务数量的增加。
浏览器渲染速度变慢
整个页面渲染过程变成了，主页面先加载，通过js找到页面的gadget，gadget去服务端请求gadget内容，内容回来后再添加到页面上，再加载gadget对应的js/css。相比原始页面的解析，页面加载的性能变差了。
      针对这些问题，我们肯定是想是否能够在开发态使用gadget组件化带来的优点，而在运行态又可以跟原生html开发保持同样的性能。

      为得到上述的效果，UEE开发了一个基于maven插件的预编译工具，在工程maven打包时可以将基于gadget组件化开发的页面进行gadget内容提前平铺、js/css合并、静态资源加上版本号等动作，保证在运行态页面展示的性能不低于原生html开发。

      基于业务当前的页面，进行了预编译前后的性能数据对比，对于营销活动页面，http请求数从预编译前的96个下降到33个，页面e2e展示时间由7.43s下降到2.32s。

      使用UEE的gadget组件化开发出的页面，如果要支持IE8浏览器，建议使用UEE的预编译工具进行预处理。预编译工具的配置与安装请参见：http://rnd-soa.huawei.com/uee/doc/guide/#/item/precompile-deploy。

4 gadget的定义和使用
      前面讨论了gadget很多相关理念，下面我们具体介绍如何定义一个gadget以及如何在页面中使用。

4.1定制gadget provider实现
UEE提供默认的gadget provider实现类FileGadgetProvider，用于处理加载gadget信息。也提供了可供业务定制的gadget provider接口GadgetProvider：

package com.huawei.uee.web.gadget;
/**
 * gadget服务接口类
 */
public interface GadgetProvider
{
    /**
     * 获取gadget信息
     */
    GadgetInfo getGadget(String gadgetName);
}
接口回调方式为：业务侧在spring配置该接口的实现类，作为bean，并将其beanid通过1+N方式赋予“*.web.properties”文件中如下配置项：

#The gadget provider bean name, see bean "gadget.service" in uee.jaxrs.service.xml
uee.gadget.provider = gadget.provider.file
4.2定义gadget
新建一个文件夹，建议以gadget名称来命名，如my-photoalbum。
说明：gadget文件夹的存放路径可以通过1+N配置项进行配置。FileGadgetProvider中提供的gadget默认的加载路径为“/gadgets/xx/*.gadget”，在uee的“*.web.properties”文件的uee.gadgets.location配置项中进行配置，业务可以通过1+N机制覆盖。

在文件夹中新建my-photoalbum.gadget文件以及gadget需要的js/css资源。

为了使您的gadget更好的支持在composer上开发、定制，您还需要在“*.gadget”文件中定义一系列元数据。
典型的“*.gadget”文件如下，完整样例详见Sample.gadget。

<!-- 
@description 
        这里是gadget的描述信息，可以在这里描述此gadget的用途；
        这里的文本将在Composer或组件市场的管理页面中呈现；
        这里的文本可以使用国际化  {{KEY}}， 对于标签内容与标签属性国际化规则详见 http://rnd-github.huawei.com/soa/uee/issues/101
        这里的文本不打算支持富本文，暂时也没有支持markdown的计划，你也可以告诉我们你的想法。
        其他的一些约定：
        1、Gadget组件截图：
             Gadget目录中"/sreenshots"子文件夹内的图片将作为Gadget在Composer或组件市场上的样例截图；不需要额外配置；
        2、Gadget的缩略图：
            约定为Gadget路径下的"gadget同名.png图片"
@creator  Jan Smith
@version  1.0
@icon /sample.png
        1）url以"/"开头则从Gadget路径内部加载；url不以"/"开头则直接加载，比如http://...等 
        2）没有配置时，约定为Gadget路径下的gadget同名.png图片            
@service {/demo/service1/} 使用了xxxx服务，用来加载xx数据；
@service {/demo/service2/} 依赖yyyy服务，加载y数据；
@service {/demo/service3/} 使用了zzzz服务，加载z； 
@event-on {$abc} 本Gadget依赖$abc事件
@event-emit {$hello} 发布这个事件
@event-emit {$ready} 发布这个事件
 -->
    <!-- gadget唯一id命名，该name会自动转换为my-photoalbum作为class属性，如-->
    <!-- <div class="uee-gadget ng-scope my-photoalbum" gadget="" name="my:photoalbum">-->
    <uee:gadget-define name="my:photoalbum" label="样例Gadget" style="width:450px;height:350px" >
    <!-- gadget属性申明，跟.gadget文件的头注释一起作为gadget的元数据-->
    <uee:gadget-attr  name="myname"  label="Name" required="true" description="这个属性填写名称"></uee:gadget-attr>
    <uee:gadget-attr  name="myage" label="Age" defaultvalue="32" description="这个属性填写年龄，默认为32"></uee:gadget-attr>
    <uee:gadget-attr  name="myphoto"  label="Photo" defaultvalue="resource.root/gadgets/my-photoalbum/headshot.jpg" ></uee:gadget-attr>
    <uee:gadget-attr  property="exp"  label="Expression" description="此属性值会由exp表达式在上下文中求值得出; "></uee:gadget-attr>
    ......
    <!-- gadget引用静态资源建议使用{{$Gadget.$Path}}引用本gadget路径下的资源--> 
    <link type="text/css" rel="stylesheet" ng-href="{{$Gadget.$Path }} / photoalbum.css"/>
    <uee:script src="{{$Gadget.$Path + '/ photoalbum.js'}}"></uee:script>
    <!--gadget内容可以是原生html，也可以通过include一个公共的代码块-->
    <div>......</div>
    <!--可选，gadget中可以订阅事件-->
    <uee:fire event="$my. photoalbum.addiProdSelected" script="......"></uee:fire>
    <!--可选，gadget中可以发布事件，并携带参数-->
    <uee:fire script="$Gadget.$Emit('$hello',{id:’test’})"></uee:fire>
    <!--可选，gadget中通过restful加载数据，数据可以存储到$Gadget内部，与外界独立-->
    <uee:fire service="my/ photoalbum //init" target="$Gadget.userdata"></uee:fire>
</uee:gadget-define>
使用gadget
在页面引入gadget，推荐通过如下方式引入gadget：

<my:photoalbum gadget name=”hello”></my:photoalbum >
注意：IIE8浏览器不认识非w3c标准的element元素，如my:photoalbum，需要在html头部申明bes的namespace （IE的namespace相关说明可参考：https://msdn.microsoft.com/en-us/library/dd565690(v=vs.85).aspx ），如下：

<html xmlns:ng="" xmlns:uee="" xmlns:my="">
5 gadget的定制
      gadget作为页面组件化的一部分，在华为的局点交付模式下，势必要回答一个问题，即如何定制。

5.1 页面级别的调整
      通过gadget开发出来的页面，局方维护人员通过UEEComposer工具，对基于gadget的页面，可以方便的对页面中的gadget进行增加、删除、修改等调整，并可根据gadget暴露出来的属性，对gadget进行配置，甚至还可以修改gadget的定义并保存。

5.1.1 Composer属性设置
      gadget属性通过type指定属性设置展示类型，当前支持的类型：input、radio、select、checkbox、custom。

input
<uee:gadget-attr  name="title" label="标题" type="input" defaultvalue="title">
</uee:gadget-attr>
     fig5_1
radio
<uee:gadget-attr  name="displayTitle" label="显示标题" type="radio" defaultvalue="0" 
items="{0:'显示',1:'不显示'}"></uee:gadget-attr>
``` fig5_3
select
<uee:gadget-attr  name="turnEffect" label="切换效果" type="select" defaultvalue="0" 
items="{0:'上下滚动',1:'渐变滚动'}"></uee:gadget-attr>
fig5_4
checkbox
<uee:gadget-attr  name="isVisiable" label="是否显示" type="checkbox" defaultvalue="0" 
items="{0:'折扣价,1:'最近30天',2:'累计评价数',3:'评论'}"></uee:gadget-attr>
``` fig5_5
custom(自定义html片段内容)
<uee:gadget-attr label="样式" type="custom" src="$Gadget.$Path + '/custom.uslx'">
</uee:gadget-attr>
说明： 自定义配置界面创建的临时变量（如：$Gadget.selectedCols）需要在界面初始化时清空，否则再次打开配置界面会展示冗余信息。
支持group分组
      组件属性编辑支持group（支持国际化）分组，不同分组展示在不同tab页下，不指定分组则展示在默认分组（属性编辑）下，指定相同分组则展示在同一tab页。
<!--不指定分组则使用默认分组（属性编辑）-->
<uee:gadget-attr label="SOA.UC.COMMON.LABEL.TITLE" defaultvalue="缺省标题" name="title" type="input">
</uee:gadget-attr> 
<uee:gadget-attr  group="组别1" label="SOA.UC.INDEX.MENU.TEMPLATE.SELECT" name="desc" type="radio" defaultvalue="02" items="{'01': '单选1', '02': '单选2', '03': '单选3'}">
</uee:gadget-attr>
<uee:gadget-attr  group="组别1" label="SOA.UC.COMMON.LABEL.CATEGORY" name="category" type="select" defaultvalue="1" items="{'1': '下拉1', '2': 'SOA.UC.COMMON.LABEL.CATEGORY'}">
</uee:gadget-attr>
<uee:gadget-attr  group="组别2" label="SOA.UC.COMMON.LABEL.TYPE" name="type" type="checkbox" defaultvalue="a,c" items="{'a: '多选1','b': '多选2', 'c': '多选3', 'd': '多选4'}">
</uee:gadget-attr>
分组效果：
fig5_6
支持event
      gadget attr上增加事件（event），属性值修改后会触发该事件。
增加event属性，如下：
<uee:gadget-attr  name="urlprefix" label="urlprefix" event="$uEditorIsReady">
</uee:gadget-attr>
接收事件示例代码：
<script>
 function initContent(gadget)
 {
     // 响应事件
     // alert(gadget.$Attrs.urlprefix); 
 }
</script>
<uee:fire event="$uEditorIsReady" script="initContent($Gadget)"></uee:fire>
或者
$Gadget.$on('$uEditorIsReady', function(event,data) {  
 // data即为$Gadget对象
 // alert(data.$Attrs.urlprefix);       
});
说明：

属性items和defaultvalue可以从模型中获取，如items=“$Gadget.effects”。
label属性建议设置为国际化key。
5.1.2 gadget扩展点
gadget提供扩展点，定制人员可以通过编写web代码在gadget中加入自己的逻辑，实现对gadget定制。

约束
多个扩展点不能同行。
gadet嵌套时，不支持将gadget直接写在父gadget的“*.gadget”文件中。
gadget内部多级目录时，不支持自动打开uslx或者html。
使用方法
基线人员预置扩展点。
在Dom元素上定义class='u-extend'，并设置该Dom元素的id，以此标识此处是一个扩展点。
<div id="cardContent1" desc="该扩展点用于扩展card套餐表单" class="u-extend"></div>
其中class和id必须设置。
定制人员通过composer在扩展点处进行定制。
详细操作方法请参见“Composer操作指南 > 通过扩展点编辑”。
5.2 系统级别的风格定制
      如果基线代码需要针对某个局点进行全面的风格调整，这时建议直接采用1+N的方式对gadget做定制开发。

      上面提到过gadget本身所在的路径是通过配置文件进行配置的，通过“*.web.properties”文件（具体要参考当前系统的1+N配置策略）中的uee.gadgets.location选项进行配置。例如可配置如下：

//基线配置
uee.gadgets.location = /gadgets/basic/*.gadget
//局点定制配置
uee.gadgets.location = /gadgets/jsyd/*.gadget
通过上面的配置，可以在对应的目录下，对基线已有的gadget进行改造，风格适配。

5.2.1多租下gadget的定制配置
​ 多租户场景下，对gadget做定制开发，需要处理租户间的gadget资源隔离。uee支持通过配置正则表达式，来区分租户gadget与基线gadget。

​ 业务需要在“*.web.properties”文件中增加uee.tenant.pattern 配置项。配置示例如下：

//其中gagdets与case代表了业务基线gadget相对webroot的相对路径的根目录名称
//需要将基线gadget根目录全部包含在正则中，根目录以'/'结尾，以'|'分隔
uee.tenant.pattern = ^/(?!(gadgets/|case/))([^/]+)
​ 为了让uee能够获取租户名称，业务需要在浏览器端Cookie中增加租户名称项，并在后端国际化文件中增加UEE.TENANT.COOKIE=tenant_space_id项，其中tenant_space_id 为Cookie中租户名称信息的key值(tenant_space_id仅为示例，业务根据场景配置)。

6 gadget最佳实践
6.1 gadget必须有全系统唯一的name
      gadget是以唯一name进行区分调用，对于大型Web项目来说，运行态涉及到多个模块集成，对gadget的命名建议使用系统名-模块名-gadget名的方式进行命名，如bes-oc-account-jsyd。

6.2 gadget保持独立性
      当gadget确实需要跟外界进行交互时，一是通过gadget属性传递对象，二是通过uee:fire去订阅和发布事件。

6.2.1 通过gadget属性传递对象交互
      将gadget的属性设置为一个对象，在gadget内部通过属性对该对象进行操作，通过该对象与外界进行数据交互。

gadget定义：
<uee:gadget-define name=”my:gadget”>
    <!--通过property属性将一个属性data定义为object类型-->
    <uee:gadget-attr property=”data”></uee:gadget-attr>
    <!--通过Gadget中内置变量$Attrs获取外部传递过来的属性data-->
    <div>{{$Attrs.data.xxx}}</div>
......
gadget使用：
<!--将data属性赋值为一个指向js对象的表达式-->
<my:gadget gadget data=”$Model.object”></my:gadget>
6.2.2 通过事件进行交互
      不同的gadget之间常需要交互一些信息，如行为、展示或数据等。gadget提供事件机制，用来实现不同的gadget之间的交互。 当一个gadget发出事件后，前台页面上其他感兴趣的gadget可以捕获该事件，从而获得该事件的发送者信息，该事件的数据、类型等参数。

      发送/接收事件均写在gadget定义文件中。

发送事件
在gadget定义文件“my-photoalbum.gadget”里写如下fire：

<uee:fire script="$Gadget.$Emit (eventName, data)"></uee:fire>
eventName：发送的事件名称
data：data是事件携带的参数对象
示例：

<button label=”send message”>
    <uee:fire script="$Gadget.$Emit('$hello',{id:$Attrs.id, key:value})"></uee:fire>
</button>
接收事件
在gadget定义文件“my-photoalbum.gadget”里写如下fire：

<uee:fire event="$hello" script="$Controller.sayHello($Gadget, $Event.$Data)"></uee:fire>

说明：

$hello是自定义事件，自定义事件需要以$符号开头。
$Event.$Data是提供给业务的内置变量，用于获取事件参数。
这里$Event.$Data.id可以获取到发送事件时携带的id参数。
本示例接收到$hello事件，调用$Controller.sayHello处理事件。
$Controller.sayHello定义在gadget的js文件中，示例如下:
$Controller("sayHello", function($Gadget, data) {
  if(data.id != $Gadget.$Attrs.id){
     $Gadget.msg = [data.id, data.msg, data.tagName];
   }
})
6.2.3 避免在gadget内部使用页面级别的变量、Dom元素
      例如，如下gadget中的代码大量使用$Page对象，不推荐： fig6_2_3

6.3 gadget的资源内聚
      一个gadget相关的html/js/css/images资源建议在物理形态上放在一个目录，便于后续gadget维护，分享，重用，以及在composer上对进行基于gadget的页面定制。（后续使用组件市场能力将组件，gadget在机制上形成共享）。

6.4 gadget内部js资源中的函数定义建议使用$Controller定义，使用跟gadget名关联的全局唯一命名空间
      gadget内部的js资源，在申明函数时，建议使用$Controller申明带命名空间的函数名，如：

$Controller("bes.oc.jsyd.account.init",function(){
     ……
})
6.5 gadget内部css资源中的选择器建议使用跟gadget名关联的全局唯一命名空间
      gadget内部的css资源中的选择器需要保持系统唯一，建议在gadget内部的dom的class命名上，采用跟gadget名关联的全局唯一命名空间，如：

.bes-oc-jsyd-account-header{
      color:red;
}
6.6 gadget定义需要显示指定gadget支持配置的属性
      gadget在定义时，需要通过uee-gadget-attr标签显式指定支持配置哪些属性，以及属性的可能默认值，以便后续web composer在线编辑（参见5.1.1）。如：

<uee:gadget-attr name="offeringid" label="offeringid"></uee:gadget-attr> 
    <uee:gadget-attr name="businessmodel" defaultvalue="P" type="select" label=" businessmodel "></uee:gadget-attr> 
<!-- 业务模式:P-集团产品订购，M_A-集团成员管理（新增），M-U-集团成员管理（修改） -->
    <uee:gadget-attr name="relationtype" type="radio" defaultvalue="P"></uee:gadget-attr> 
<!-- 商品关系:P-集团可订购， M-成员可订购 -->
    <uee:gadget-attr name="showcategories" type="radio" defaultvalue="0"></uee:gadget-attr> 
<!-- 是否展示销售目录:1-展示， 0-不展示 -->
    <uee:gadget-attr name="opcode" type="select"></uee:gadget-attr> 
<!--  A-新增 M-修改 -->
6.7 gadget内部的js代码加载时不直接操作Dom
      在gadget中定义的js文件，在加载时，避免执行操作dom，而应该只是定义函数，具体操作dom的时机由uee:fire组件触发。 避免由于后续预编译时gadget内部js文件被提取合并引起的代码执行顺序问题，导致的js错误。

错误代码：

<script>
    var printCelljsyd = $('.cellweb');
printCelljsyd.Login("华为技术有限公司","","13100104539","6140-1517-0123-3005");
</script>
推荐写法：

<uee:fire init script=” $Controller.bes.xxxxPage.init()”></uee:fire>
<script>
$Controller("bes.xxxxPage",{
   init:function(){
    var printCelljsyd = $('.cellweb');
    printCelljsyd.Login("华为技术有限公司","","13100104539","6140-1517-0123-3005");
  }
})
</script>
